<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Agente PITE (Streaming)</title>

  <style>
    html, body { margin: 0; padding: 0; height: 100%; }

    body{
      min-height: 100vh;
      font-family: Arial, Helvetica, sans-serif;
      background-image: url("Tadayuki.png");
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
    }

    body::before{
      content:"";
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.10);
      pointer-events: none;
    }

    /* ‚úÖ Avatar ‚Äì centro da p√°gina (maior) */
    #piteAvatar {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 320px;              /* <-- maior (ajuste aqui se quiser) */
      height: auto;
      z-index: 2147483000;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
      filter: drop-shadow(0 14px 28px rgba(0,0,0,0.30));
    }

    /* Bot√£o */
    #btnCall {
      position: fixed;
      top: 24px;
      left: 24px;
      z-index: 2147483647;
      padding: 10px 14px;
      border: 0;
      border-radius: 12px;
      font-weight: 700;
      cursor: pointer;
      background: rgba(255,255,255,0.92);
      box-shadow: 0 10px 18px rgba(0,0,0,0.15);
      -webkit-tap-highlight-color: transparent;
    }

    #status {
      position: fixed;
      top: 76px;
      left: 24px;
      z-index: 2147483647;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(0,0,0,0.55);
      color: #fff;
      font-size: 12px;
      max-width: 340px;
    }

    /* ‚úÖ Responsivo */
    @media (max-width: 480px){
      #piteAvatar{
        width: 240px;  /* menor no celular */
      }
      #btnCall{ top: 12px; left: 12px; padding: 10px 12px; }
      #status{ top: 60px; left: 12px; max-width: 280px; }
    }
  </style>
</head>

<body>
  <img id="piteAvatar" src="pitepiscando.gif" alt="Avatar PITE" />
  <button id="btnCall" type="button">üéôÔ∏è Iniciar conversa</button>
  <div id="status">Status: parado</div>

  <script>
    const GIF_FALANDO = "pitebocaberta.gif";
    const GIF_PARADO  = "pitepiscando.gif";

    const avatar = document.getElementById("piteAvatar");
    const btn = document.getElementById("btnCall");
    const statusEl = document.getElementById("status");

    let ws = null;

    // mic
    let micStream = null;
    let micCtx = null;
    let micSource = null;
    let micProc = null;
    let micZeroGain = null;

    // player
    let audioCtx = null;
    let speakingTimeout = null;
    let rodando = false;

    // ‚úÖ fila de reprodu√ß√£o do √°udio do agente (evita sobreposi√ß√£o)
    let nextPlayTime = 0;

    function setStatus(t){ statusEl.textContent = "Status: " + t; }

    function setSpeaking(on) {
      avatar.src = on ? GIF_FALANDO : GIF_PARADO;
      if (speakingTimeout) clearTimeout(speakingTimeout);
      if (on) speakingTimeout = setTimeout(() => setSpeaking(false), 700);
    }

    function floatTo16BitPCM(float32) {
      const buf = new ArrayBuffer(float32.length * 2);
      const view = new DataView(buf);
      for (let i = 0; i < float32.length; i++) {
        let s = Math.max(-1, Math.min(1, float32[i]));
        view.setInt16(i*2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
      }
      return new Uint8Array(buf);
    }

    function toBase64(u8) {
      let s = "";
      for (let i=0;i<u8.length;i++) s += String.fromCharCode(u8[i]);
      return btoa(s);
    }

    function fromBase64(b64) {
      const bin = atob(b64);
      const u8 = new Uint8Array(bin.length);
      for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
      return u8;
    }

    // ‚úÖ PLAY com fila (scheduling) para n√£o tocar chunks ao mesmo tempo
    function playPcm16(u8, sampleRate = 16000) {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
      const f32 = new Float32Array(u8.byteLength / 2);
      for (let i=0;i<f32.length;i++) f32[i] = dv.getInt16(i*2, true) / 0x8000;

      const buf = audioCtx.createBuffer(1, f32.length, sampleRate);
      buf.copyToChannel(f32, 0);

      const now = audioCtx.currentTime;
      if (nextPlayTime < now) nextPlayTime = now; // se houve gap, recome√ßa fila

      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      src.connect(audioCtx.destination);

      src.start(nextPlayTime);
      nextPlayTime += buf.duration;

      // mant√©m o avatar "falando" enquanto tiver √°udio na fila
      setSpeaking(true);
      if (speakingTimeout) clearTimeout(speakingTimeout);

      const ms = Math.max(250, Math.ceil((nextPlayTime - audioCtx.currentTime) * 1000));
      speakingTimeout = setTimeout(() => setSpeaking(false), ms);
    }

    async function getSignedUrl() {
      const r = await fetch("/api/token", { cache: "no-store" });
      if (!r.ok) throw new Error(await r.text());
      const j = await r.json();
      if (!j.signed_url) throw new Error("signed_url n√£o veio do /api/token");
      return j.signed_url;
    }

    async function startMicAndSend() {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // muitos devices usam 48k, faremos downsample simples p/ 16k
      micCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
      micSource = micCtx.createMediaStreamSource(micStream);
      micProc = micCtx.createScriptProcessor(2048, 1, 1);

      micProc.onaudioprocess = (e) => {
        if (!ws || ws.readyState !== 1) return;

        const input = e.inputBuffer.getChannelData(0);
        const ratio = micCtx.sampleRate / 16000; // ex: 3
        const outLen = Math.floor(input.length / ratio);
        const down = new Float32Array(outLen);
        for (let i=0;i<outLen;i++) down[i] = input[Math.floor(i*ratio)];

        const pcm16 = floatTo16BitPCM(down);
        ws.send(JSON.stringify({ user_audio_chunk: toBase64(pcm16) }));
      };

      micSource.connect(micProc);

      // ‚úÖ N√£o tocar microfone no speaker: conecta com gain 0
      micZeroGain = micCtx.createGain();
      micZeroGain.gain.value = 0;
      micProc.connect(micZeroGain);
      micZeroGain.connect(micCtx.destination);
    }

    function stopAll() {
      rodando = false;
      setSpeaking(false);

      // ‚úÖ reseta fila para n√£o ‚Äúcarregar‚Äù √°udio antigo
      nextPlayTime = 0;

      try { if (ws) ws.close(); } catch(e) {}
      ws = null;

      if (micProc) { try { micProc.disconnect(); } catch(e) {} }
      if (micSource) { try { micSource.disconnect(); } catch(e) {} }
      if (micZeroGain) { try { micZeroGain.disconnect(); } catch(e) {} }
      if (micCtx) { try { micCtx.close(); } catch(e) {} }

      micProc = micSource = micZeroGain = micCtx = null;

      if (micStream) {
        micStream.getTracks().forEach(t => t.stop());
        micStream = null;
      }

      btn.textContent = "üéôÔ∏è Iniciar conversa";
      setStatus("parado");
    }

    async function startAll() {
      rodando = true;
      btn.textContent = "‚õî Parar conversa";
      setStatus("conectando...");

      const signedUrl = await getSignedUrl();
      ws = new WebSocket(signedUrl);

      ws.onopen = async () => {
        setStatus("microfone...");
        await startMicAndSend();

        ws.send(JSON.stringify({
          type: "conversation_initiation_client_data",
          dynamic_variables: { site: "PITE" }
        }));

        setStatus("ativo (fale algo)");
      };

      ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);

        if (msg.type === "audio" && msg.audio_event?.audio_base_64) {
          const u8 = fromBase64(msg.audio_event.audio_base_64);
          playPcm16(u8, 16000);
        }
      };

      ws.onerror = (e) => {
        console.error(e);
        setStatus("erro");
        stopAll();
        alert("Erro ao conectar no agente (ver console).");
      };

      ws.onclose = () => {
        if (rodando) stopAll();
      };
    }

    btn.addEventListener("click", async () => {
      try {
        if (rodando) stopAll();
        else await startAll();
      } catch (err) {
        console.error(err);
        stopAll();
        alert("Falhou: " + (err?.message || err));
      }
    });
  </script>
</body>
</html>
